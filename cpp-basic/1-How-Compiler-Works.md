# How Compiler works

> By __d3cod3monk__

---

## Content

- [How Compiler works](#how-compiler-works)
  - [Content](#content)
  - [How to Run a program](#how-to-run-a-program)
  - [Compiling process](#compiling-process)
  - [Preprocessor](#preprocessor)
  - [Compiler](#compiler)
  - [Assembler](#assembler)
  - [Linker](#linker)
  - [Compiling result files](#compiling-result-files)
  - [Makefile - A way of compiling projects](#makefile---a-way-of-compiling-projects)

## How to Run a program

```bash
    g++ -Wall -o test prac.cpp -std=c++17
```

- test: The executing file name
- prac.cpp: The source code file

---

## Compiling process

The following are the phases through which our program passes before being transformed into an executable form:

- Preprocessor
- Compiler
- Assembler
- Linker

![Executable process](https://static.javatpoint.com/cpages/images/compilation-process-in-c2.png)

[_image source_](https://www.javatpoint.com/compilation-process-in-c "Java point")

---

## Preprocessor

>The source code is the code which is written in a text editor and the source code file is given an extension "_.cpp_". This source code is first passed to the preprocessor, and then the preprocessor expands this code. After expanding the code, the expanded code is passed to the _compiler_.

---

## Compiler

>The code which is expanded by the preprocessor is passed to the compiler. The compiler converts this code into assembly code. Or we can say that the Cpp compiler converts the pre-processed code into assembly code.

---

## Assembler

>The assembly code is converted into object code by using an assembler. The name of the object file generated by the assembler is the same as the source file. The extension of the object file in DOS is '.obj,' and in UNIX, the extension is 'o'. If the name of the source file is 'hello.c', then the name of the object file would be 'hello.obj'.

---

## Linker

>Mainly, all the programs written in C use library functions. These library functions are pre-compiled, and the object code of these library files is stored with '.lib' (or '.a') extension. The main working of the linker is to combine the object code of library files with the object code of our program. Sometimes the situation arises when our program refers to the functions defined in other files; then linker plays a very important role in this. It links the object code of these files to our program. Therefore, we conclude that the job of the linker is to link the object code of our program with the object code of the library files and other files. The output of the linker is the executable file. The name of the executable file is the same as the source file but differs only in their extensions. In DOS, the extension of the executable file is '.exe', and in UNIX, the executable file can be named as 'a.out'. For example, if we are using `printf()` function in a program, then the linker adds its associated code in an output file.

---

## Compiling result files

![Compiling result files](https://static.javatpoint.com/cpages/images/compilation-process-in-c3.png)

---

## Makefile - A way of compiling projects

> __Make__ is _Unix_ utility that is designed to start execution of a makefile. A makefile is a special file, containing shell commands, that you create and name makefile (or Makefile depending upon the system). While in the directory containing this makefile, you will type make and the commands in the makefile will be executed. If you create more than one makefile, be certain you are in the correct directory before typing make.

- makefile format

```makefile
    target: dependencies
        [tab]action

    dependency line: target files
        [tab]action / source files
```

- example

```makefile
    # -*- MakeFile -*-

    #target: dependencies
    #   action

    .PHONY: all test main.o message.o clean

    all: test

    test: main.o message.o
        g++ -Wall main.o message.o -o test -std=c++17

    main.o: main.cpp main.h
        g++ -Wall -c main.cpp -std=c++17

    message.o: message.cpp message.h
        g++ -Wall -c message.cpp -std=c++17

    clean:
        rm *.o test

```

And run project with

```bash
    make
    ./test
```

- to clean the odd files

```bash
    make clean
```
